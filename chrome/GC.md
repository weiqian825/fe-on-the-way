### 一、前言

1. JS 8 种数据 = 原始类型（栈） + 引用类型（堆）
2. JS 内存模型 = 代码空间 + 栈空间 + 堆空间

 堆的构成

```
新生区：大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。

老生指针区：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。

老生数据区：这里存放只包含原始数据的对象（这些对象没有指向其他对象的指针）。字符串、封箱的数字以及未封箱的双精度数字数组，在新生区存活一段时间后会被移动到这里。

大对象区：这里存放体积超越其他区大小的对象。每个对象有自己mmap产生的内存。垃圾回收器从不移动大对象。

代码区：代码对象，也就是包含JIT之后指令的对象，会被分配到这里。这是唯一拥有执行权限的内存区（不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的。译注：但是大对象内存区本身不是可执行的内存区）

Cell区、属性cell区、map区：这些区域存放Cell、属性Cell和Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单。
```

每个区域都由一组内存页构成。内存页是一块连续的内存，经 mmap（或者 Windows 的等价物）由操作系统分配而来。

### 二、垃圾回收

1. 不同语言垃圾回收策略

```
手动回收： C++
自动回收： Javascript Java Python
```

2. 怎么回收垃圾

```
识别垃圾 + 清理垃圾 + 内存整理
a. 标记活动空间中活动对象和非活动对象
b. 回收非活动对象所占据的内存
c. 内存整理（频繁回收对象后，内存中会存在内存碎片）
```

3. 副垃圾回收器(新生代)

```
算法：Scavenge算法
a. 把新生代空间对半划分成两个区域，一半对象区域，一半儿空闲区域
b. 新加入的对象放到对象区域，对象区域快写满时候执行一次垃圾清理操作
c. 垃圾清理，先标记，标记完成后，回收器把存活对象复制到空闲区域，同时有序排列，复制过程中相当于完成了内存整理
d. 复制完成后，对象区域和内存区完成反转，反转让新生代的两块区域无限重复使用下去,每次执行清理都有复制动作，为了执行效率新生代一般都会设置的比较小

JS引擎使用对象晋升策略: 经过2次垃圾回收还存活的对象会被放到老生区
```

4. 主垃圾回收器（老生 标记清除算法（Mark-Sweep）+标记整理算法（Mark-Compact））

```
老生区对象一般有2个特点：一个是对象占用空间大，另一个是对象存活时间长

算法：标记-清除（Mark-Sweep）算法
标记：从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据

算法：标记-整理（Mark-Compact）
整理： 所有的存活对象向一端移动，直接清掉端边界以外的内存
```

5. 全停顿

```
一旦执行垃圾回收算法，都需要将正在执行的JS脚本暂时停下来，待垃圾回收完毕后再恢复脚本执行
增量标记算法：为了降低老生代垃圾回收而造成的卡顿，V8将标记过程分为一个个子标记的过程，让垃圾回收标记和应用程序逻辑交替进行，直到标记完成。
```

6. 栈中的垃圾回收

```
栈中的过期数据直接通过esp给抹掉，不需要通过V8的垃圾回收机制的，效率非常高
```

7. 判断 JS 内存泄露？

```
1. 感官上的长时间运行页面卡顿，猜可能会有内存泄漏。过Chrome开发者工具中的Performance来观察
2. 工作中避免内存泄漏方法：确定不使用的临时变量置为null，当前es6普及场景下少使用闭包也是一种方法。
```

### 相关文章

http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection
https://javascript.info/garbage-collection#unreachable-island
https://plumbr.io/handbook/what-is-garbage-collection
https://medium.com/coding-blocks/catching-memory-leaks-with-chrome-devtools-57b03acb6bb9
